<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI-BITBOY-DEX-202X — Singlefile (Offline)</title>
<style>
  :root {
    --bg1: #0a0e17;
    --bg2: #131a2d;
    --panel: #150a30;
    --accent: #00ffcc;
    --accent2: #ff00ff;
    --text: #e6f7ff;
    --muted: #9fb0c9;
    --success: #00ff88;
    --danger: #ff4d4d;
    --warning: #ffaa00;
    --border-color: rgba(0, 255, 204, 0.14);
    --glass: rgba(255, 255, 255, 0.02);
    --panel-border: 1px solid var(--border-color);
    --panel-radius: 12px;
    --panel-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
  }
  
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: 'Inter', 'Roboto Mono', monospace;
  }
  
  html, body {
    height: 100%;
    background: linear-gradient(135deg, var(--bg1), var(--bg2));
    color: var(--text);
    -webkit-font-smoothing: antialiased;
    overflow-x: hidden;
  }
  
  .container {
    max-width: 1400px;
    margin: 18px auto;
    padding: 18px;
  }
  
  header {
    margin-bottom: 24px;
    border-bottom: var(--panel-border);
    padding-bottom: 16px;
    text-align: center;
  }
  
  header h1 {
    font-size: 2.2rem;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 8px;
    text-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
  }
  
  header p {
    color: var(--muted);
    font-size: 1rem;
  }
  
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
  }
  
  .panel {
    background: var(--panel);
    border: var(--panel-border);
    border-radius: var(--panel-radius);
    padding: 20px;
    box-shadow: var(--panel-shadow);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }
  
  .panel:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
  }
  
  .panel-title {
    display: flex;
    align-items: center;
    gap: 10px;
    color: var(--accent);
    margin-bottom: 16px;
    font-weight: 700;
    font-size: 1.2rem;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }
  
  .panel-title svg {
    width: 20px;
    height: 20px;
  }
  
  .big {
    font-size: 1.8rem;
    font-weight: 800;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  
  .muted {
    color: var(--muted);
    font-size: 0.9rem;
  }
  
  .chart-canvas {
    width: 100%;
    height: 160px;
    background: linear-gradient(180deg, rgba(0, 255, 204, 0.02), transparent);
    border-radius: 8px;
    margin-top: 10px;
  }
  
  .ai-log {
    background: var(--glass);
    padding: 12px;
    border-radius: 8px;
    height: 160px;
    overflow: auto;
    font-family: 'Roboto Mono', monospace;
    font-size: 0.85rem;
    line-height: 1.4;
  }
  
  .feed {
    height: 220px;
    overflow: auto;
    background: linear-gradient(180deg, rgba(0, 0, 0, 0.02), transparent);
    padding: 10px;
    border-radius: 8px;
    font-family: 'Roboto Mono', monospace;
    font-size: 0.9rem;
    line-height: 1.4;
  }
  
  .row {
    display: flex;
    gap: 12px;
    margin: 12px 0;
  }
  
  .col {
    flex: 1;
  }
  
  .btn {
    padding: 12px 16px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    transition: all 0.2s ease;
  }
  
  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  }
  
  .btn-primary {
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    color: #000;
  }
  
  .btn-success {
    background: var(--success);
    color: #082018;
  }
  
  .btn-danger {
    background: var(--danger);
    color: #fff;
  }
  
  .btn-warning {
    background: var(--warning);
    color: #000;
  }
  
  .small {
    font-size: 0.9rem;
  }
  
  .kv {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 12px 0;
  }
  
  input, select {
    padding: 10px;
    border-radius: 8px;
    background: var(--glass);
    border: 1px solid var(--border-color);
    color: var(--text);
    font-family: 'Roboto Mono', monospace;
  }
  
  input:focus, select:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(0, 255, 204, 0.2);
  }
  
  .controls {
    display: flex;
    gap: 12px;
    justify-content: center;
    margin-top: 20px;
    flex-wrap: wrap;
  }
  
  .status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 8px;
  }
  
  .status-online {
    background: var(--success);
    box-shadow: 0 0 8px var(--success);
  }
  
  .status-offline {
    background: var(--danger);
    box-shadow: 0 0 8px var(--danger);
  }
  
  .status-paused {
    background: var(--warning);
    box-shadow: 0 0 8px var(--warning);
  }
  
  @media (max-width: 1000px) {
    .grid {
      grid-template-columns: 1fr;
    }
    
    .row {
      flex-direction: column;
    }
    
    header h1 {
      font-size: 1.8rem;
    }
  }
  
  /* Custom scrollbar */
  ::-webkit-scrollbar {
    width: 8px;
  }
  
  ::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 10px;
  }
  
  ::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 10px;
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: var(--accent2);
  }
  
  /* Animation for status changes */
  @keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
  }
  
  .pulse {
    animation: pulse 2s infinite;
  }
  
  /* Badge styles */
  .badge {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 700;
    margin-left: 8px;
  }
  
  .badge-success {
    background: rgba(0, 255, 136, 0.2);
    color: var(--success);
  }
  
  .badge-warning {
    background: rgba(255, 170, 0, 0.2);
    color: var(--warning);
  }
  
  .badge-danger {
    background: rgba(255, 77, 77, 0.2);
    color: var(--danger);
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>AI-BITBOY-DEX-202X</h1>
      <p class="muted">Advanced Predictive Trading Simulator • Tax Pool • Healthcare Allocation • Offline Capable</p>
    </header>

    <div class="grid" id="mainGrid">
      <!-- Portfolio -->
      <div class="panel" id="panelPortfolio">
        <div class="panel-title">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 7H3v10h18V7zM19 11a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/>
          </svg>
          Portfolio Overview
        </div>
        <div class="kv">
          <div class="muted">Portfolio Value</div>
          <div id="portfolioValue" class="big">$0.00</div>
        </div>
        <div class="kv">
          <div class="muted">PnL</div>
          <div id="pnlValue" class="small muted">+0.00 (0%)</div>
        </div>
        <canvas id="portfolioChart" class="chart-canvas"></canvas>
      </div>

      <!-- AI Agent -->
      <div class="panel" id="panelAI">
        <div class="panel-title">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2a2 2 0 0 1 2 2v1h3a2 2 0 0 1 2 2v5a3 3 0 0 1-3 3v2a2 2 0 0 1-2 2h-2v0H8a2 2 0 0 1-2-2v-2a3 3 0 0 1-3-3V7a2 2 0 0 1 2-2h3V4a2 2 0 0 1 2-2h2z"/>
          </svg>
          AI Trading Agent
        </div>
        <div class="kv">
          <div class="muted">Status</div>
          <div id="aiStatus" class="small muted">
            <span class="status-indicator status-online"></span>
            INITIALIZING
          </div>
        </div>
        <div class="ai-log" id="aiLog"></div>
      </div>

      <!-- Live Feed -->
      <div class="panel" id="panelFeed">
        <div class="panel-title">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 3h18v2H3zM3 7h12v2H3zM3 11h18v2H3zM3 15h12v2H3z"/>
          </svg>
          Live Market Feed
        </div>
        <div class="feed" id="tradeFeed"></div>
      </div>

      <!-- Manual Order -->
      <div class="panel" id="panelManual">
        <div class="panel-title">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 7h12v2H4zM20 14H8v-2h12zM7 20l-5-5 5-5v10z"/>
          </svg>
          Manual Order
        </div>
        <div class="kv">
          <label class="muted">Token</label>
          <select id="tokenSelect">
            <option>BTC</option>
            <option>ETH</option>
            <option>SOL</option>
            <option>AVAX</option>
            <option>DOT</option>
          </select>
        </div>
        <div class="kv">
          <label class="muted">Amount</label>
          <input id="amountInput" type="number" value="10" min="1" step="0.1">
        </div>
        <div class="row">
          <button id="btnBuy" class="btn btn-success col">BUY</button>
          <button id="btnSell" class="btn btn-danger col">SELL</button>
        </div>
      </div>

      <!-- Tax Pool -->
      <div class="panel" id="panelTax">
        <div class="panel-title">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M5 11a4 4 0 1 0 8 0 4 4 0 0 0-8 0zM2 11a6 6 0 1 1 12 0"/>
          </svg>
          Tax Pool
        </div>
        <div class="kv">
          <div class="muted">Pool Balance</div>
          <div id="taxPoolValue" class="big">$0.00</div>
        </div>
        <div class="row">
          <button id="btnDistributeTax" class="btn btn-primary col">Distribute Tax</button>
          <button id="btnClearTax" class="btn btn-danger col">Clear Pool</button>
        </div>
      </div>

      <!-- Healthcare -->
      <div class="panel" id="panelHealth">
        <div class="panel-title">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 21s-6-4.35-9-6.75C0 10.5 2.5 6 6 6c1.92 0 3 1.5 6 1.5S16.08 6 18 6c3.5 0 6 4.5 3 8.25C18 16.65 12 21 12 21z"/>
          </svg>
          Healthcare Reserves
        </div>
        <div class="kv">
          <div class="muted">Healthcare Balance</div>
          <div id="healthBalance" class="big">$0.00</div>
        </div>
        <div class="row">
          <button id="btnDistributeHealth" class="btn btn-primary col">Distribute Health</button>
          <button id="btnClearHealth" class="btn btn-danger col">Clear Health</button>
        </div>
      </div>

    </div> <!-- grid -->

    <div class="controls">
      <button id="btnExport" class="btn btn-primary">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 3v10l4-4h-3V3zM4 20h16v2H4z"/>
        </svg>
        Export Preview
      </button>
      <button id="btnPlay" class="btn btn-success">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M8 5v14l11-7z"/>
        </svg>
        Start / Resume
      </button>
      <button id="btnPause" class="btn btn-warning">Pause</button>
      <button id="btnReset" class="btn btn-danger">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M6 19a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7H6zM19 4h-3l-1-1H9L8 4H5v2h14z"/>
        </svg>
        Reset Simulator
      </button>
    </div>
  </div>

<script>
/* =========================
   Object Model and Simulator
   ========================= */

// --- CycleCounter ---
class CycleCounter { 
  constructor(){ this.cycle = 0; } 
  nextCycle(){ return ++this.cycle; } 
  transformBoolean(flag){ return flag ? this.cycle % 2 === 0 : this.cycle % 2 !== 0; }
}

// --- EntropyMixer ---
class EntropyMixer {
  mixEntropy(timestamp, quota = 1, ratio = 1, range = [0,100]){
    const span = range[1] - range[0] || 1;
    const raw = ( (timestamp % 1000000) * ratio + Math.floor(Math.random()*quota*100) ) % span;
    const value = Math.floor(range[0] + raw);
    return { value, quota, ratio, range, index: value };
  }
}

// --- TimestampHash (lightweight) ---
class TimestampHash {
  createHash(timestamp, netWorth = 0){
    let s = `${timestamp}:${netWorth}:${Math.random()}`;
    let h = 0;
    for (let i=0;i<s.length;i++) h = (h<<5) - h + s.charCodeAt(i), h |= 0;
    return ('00000000' + (h >>> 0).toString(16)).slice(-8);
  }
  validatePastTruth(timestamp){ return Date.now() >= timestamp; }
}

// --- AddressLedger ---
class AddressLedger {
  constructor(genesisTime){ this.addresses = new Map(); this.genesis = genesisTime; }
  createAddress(id, initialBalance = 0){ this.addresses.set(id, Number(initialBalance)); }
  moveFunds(from, to, amount){
    amount = Number(amount);
    if (!this.addresses.has(from) || !this.addresses.has(to)) return false;
    const fbal = this.addresses.get(from);
    if (fbal < amount) return false;
    this.addresses.set(from, +(fbal - amount).toFixed(6));
    this.addresses.set(to, +(this.addresses.get(to) + amount).toFixed(6));
    return true;
  }
  getBalance(id){ return this.addresses.get(id) ?? 0; }
  getAll(){ return Object.fromEntries(this.addresses.entries()); }
}

/* ------------------------------
   BlockchainSimulator
   ------------------------------ */
class BlockchainSimulator {
  constructor(genesisTime){
    this.cycleCounter = new CycleCounter();
    this.entropyMixer = new EntropyMixer();
    this.timestampHasher = new TimestampHash();
    this.ledger = new AddressLedger(genesisTime);
  }
  advanceCycle(booleanState=false){
    const cycle = this.cycleCounter.nextCycle();
    const transformedState = this.cycleCounter.transformBoolean(booleanState);
    return { cycle, transformedState };
  }
  mixEntropy(quota=1, ratio=1, range=[0,100]){
    const timestamp = Date.now();
    return this.entropyMixer.mixEntropy(timestamp, quota, ratio, range);
  }
  createTimestampHash(netWorth=0){
    const timestamp = Date.now();
    const hash = this.timestampHasher.createHash(timestamp, netWorth);
    return { timestamp, hash };
  }
  validatePast(timestamp){ return this.timestampHasher.validatePastTruth(timestamp); }
  createAddress(id, initialBalance=0){ this.ledger.createAddress(id, initialBalance); }
  moveFunds(from,to,amount){ return this.ledger.moveFunds(from,to,amount); }
  getBalance(id){ return this.ledger.getBalance(id); }
  simulateStep(booleanState=false, quota=1, ratio=1, range=[0,100], netWorth=0){
    const cycleInfo = this.advanceCycle(booleanState);
    const entropyInfo = this.mixEntropy(quota, ratio, range);
    const hashInfo = this.createTimestampHash(netWorth);
    return {
      cycle: cycleInfo.cycle,
      transformed: cycleInfo.transformedState,
      entropy: entropyInfo,
      timestampHash: hashInfo,
      balances: this.ledger.getAll()
    };
  }
}

/* ------------------------------
   PredictiveEngine
   ------------------------------ */
class PredictiveEngine {
  constructor(simulator){
    this.sim = simulator;
  }
  getThreeStates(portfolioValue){
    return [
      this.sim.simulateStep(true, 5, 0.3, [0,100], portfolioValue),
      this.sim.simulateStep(true, 10, 0.6, [0,200], portfolioValue),
      this.sim.simulateStep(true, 20, 0.9, [0,300], portfolioValue)
    ];
  }
  chooseState(states, quota=7, ratio=3){
    let chosen = states[0], minDiff = Infinity;
    for (const st of states){
      const nodeScore = ((st.entropy.index || st.entropy.value) + (st.cycle || 0)) % quota;
      const diff = Math.abs(nodeScore - ratio);
      if (diff < minDiff){ minDiff = diff; chosen = st; }
    }
    return { chosen, alternatives: states, nodeScore: ((chosen.entropy.index||chosen.entropy.value)+ (chosen.cycle||0)) % quota };
  }
}

/* ------------------------------
   TaxPool
   ------------------------------ */
class TaxPool {
  constructor(rate = 0.02){ this.rate = rate; this.pool = 0; }
  collect(amount){
    const tax = amount * this.rate;
    this.pool += tax;
    return amount - tax;
  }
  distribute(addresses, sim){
    if (this.pool <= 0 || addresses.length === 0) return;
    const share = this.pool / addresses.length;
    addresses.forEach(a => {
      if (sim.ledger.addresses.has(a)){
        sim.ledger.addresses.set(a, +(sim.ledger.addresses.get(a) + share).toFixed(6));
      }
    });
    this.pool = 0;
  }
  clear(){ this.pool = 0; }
  getBalance(){ return this.pool; }
}

/* ------------------------------
   HealthcarePersona (VAT receiver)
   ------------------------------ */
class HealthcarePersona {
  constructor(name='healthcare', initial=0, vatRate=0.10){
    this.name = name; this.balance = initial; this.vatRate = vatRate;
  }
  applyVAT(amount){ const v = amount * this.vatRate; this.balance += v; return v; }
  distribute(sim, recipients=[]){
    if (this.balance <= 0 || recipients.length === 0) return;
    const share = this.balance / recipients.length;
    recipients.forEach(r => {
      if (sim.ledger.addresses.has(r)){
        sim.ledger.addresses.set(r, +(sim.ledger.addresses.get(r) + share).toFixed(6));
      }
    });
    this.balance = 0;
  }
  clear(){ this.balance = 0; }
  getBalance(){ return this.balance; }
}

/* ============================
   Instantiate core objects
   ============================ */
let sim = new BlockchainSimulator(Date.now());
sim.createAddress('alice', 100);
sim.createAddress('bob', 50);
sim.createAddress('charlie', 75);

// create tax pool and healthcare persona
const taxPool = new TaxPool(0.02);
const health = new HealthcarePersona('healthcare', 0, 0.10);
let predictor = new PredictiveEngine(sim);

/* ============================
   Lightweight Chart (canvas)
   ============================ */
function LiteChart(canvas, length=50){
  this.canvas = canvas;
  this.ctx = canvas.getContext('2d');
  this.len = length;
  this.data = Array.from({length:length}, ()=>0);
  this.draw = ()=>{
    const c = this.canvas;
    const ctx = this.ctx;
    const w = c.clientWidth; 
    const h = c.clientHeight;
    c.width = w * devicePixelRatio; 
    c.height = h * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
    ctx.clearRect(0,0,w,h);
    
    // Background gradient
    const grad = ctx.createLinearGradient(0,0,0,h);
    grad.addColorStop(0,'rgba(0,255,204,0.12)'); 
    grad.addColorStop(1,'rgba(0,255,204,0.01)');
    ctx.fillStyle = grad; 
    ctx.fillRect(0,0,w,h);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    
    // Horizontal lines
    for (let i = 0; i <= 4; i++) {
      const y = h - (i * h/4);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
    
    // Line
    ctx.beginPath(); 
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#00ffcc';
    const max = Math.max(...this.data) || 1;
    const min = Math.min(...this.data) || 0;
    const range = max - min || 1;
    
    for (let i=0;i<this.data.length;i++){
      const x = (i/(this.len-1))*(w-20)+10;
      const y = h - 10 - ((this.data[i]-min)/range)*(h-20);
      if (i===0) ctx.moveTo(x,y); 
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    
    // Filled under curve
    ctx.lineTo(w-10, h-10);
    ctx.lineTo(10, h-10);
    ctx.closePath();
    const grad2 = ctx.createLinearGradient(0,0,w,0);
    grad2.addColorStop(0,'rgba(0,255,204,0.14)'); 
    grad2.addColorStop(1,'rgba(255,0,255,0.06)');
    ctx.fillStyle = grad2; 
    ctx.fill();
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  };
  this.push = (v)=>{ this.data.push(v); if (this.data.length>this.len) this.data.shift(); this.draw(); };
  this.setAll = (arr)=>{ this.data = arr.slice(-this.len); while (this.data.length<this.len) this.data.unshift(0); this.draw(); };
  setTimeout(()=>this.draw(),50);
}

/* ============================
   DOM + UI wiring
   ============================ */
const portfolioValueEl = document.getElementById('portfolioValue');
const pnlValueEl = document.getElementById('pnlValue');
const aiStatusEl = document.getElementById('aiStatus');
const aiLogEl = document.getElementById('aiLog');
const tradeFeedEl = document.getElementById('tradeFeed');
const taxPoolValueEl = document.getElementById('taxPoolValue');
const healthBalanceEl = document.getElementById('healthBalance');
const btnDistributeTax = document.getElementById('btnDistributeTax');
const btnClearTax = document.getElementById('btnClearTax');
const btnDistributeHealth = document.getElementById('btnDistributeHealth');
const btnClearHealth = document.getElementById('btnClearHealth');
const btnBuy = document.getElementById('btnBuy');
const btnSell = document.getElementById('btnSell');
const tokenSelect = document.getElementById('tokenSelect');
const amountInput = document.getElementById('amountInput');
const btnExport = document.getElementById('btnExport');
const btnPlay = document.getElementById('btnPlay');
const btnPause = document.getElementById('btnPause');
const btnReset = document.getElementById('btnReset');

const canvas = document.getElementById('portfolioChart');
const liteChart = new LiteChart(canvas, 50);

// local state
let portfolioValue = Object.values(sim.ledger.getAll()).reduce((a,b)=>a+b,0);
let running = true;
let lastChosen = null;

// UI helpers
function appendAI(msg, kind='info'){
  const el = document.createElement('div'); 
  el.style.padding='6px 4px'; 
  el.style.borderBottom='1px solid rgba(255,255,255,0.02)';
  
  let badge = '';
  if (kind === 'error') badge = '<span class="badge badge-danger">ERROR</span>';
  else if (kind === 'success') badge = '<span class="badge badge-success">SUCCESS</span>';
  else if (kind === 'warning') badge = '<span class="badge badge-warning">WARNING</span>';
  
  el.innerHTML = `<div style="font-size:0.85rem;color:${kind==='error'?'#ff9999':kind==='success'?'#9fe6b4':'#cfe6ff'}">${new Date().toLocaleTimeString()} — ${msg} ${badge}</div>`;
  aiLogEl.prepend(el);
  if (aiLogEl.childElementCount>40) aiLogEl.removeChild(aiLogEl.lastChild);
}

function appendFeed(msg, cls='') {
  const el = document.createElement('div'); 
  el.style.padding='6px 4px'; 
  el.style.borderBottom='1px solid rgba(255,255,255,0.02)';
  el.innerHTML = `<div style="font-size:0.9rem">${msg}</div>`;
  tradeFeedEl.prepend(el);
  if (tradeFeedEl.childElementCount>80) tradeFeedEl.removeChild(tradeFeedEl.lastChild);
}

function updateTaxUI(){ 
  taxPoolValueEl.textContent = '$' + taxPool.getBalance().toFixed(2); 
}

function updateHealthUI(){ 
  healthBalanceEl.textContent = '$' + health.getBalance().toFixed(2); 
}

function updatePortfolioUI(val, pnlText){
  portfolioValueEl.textContent = '$' + (val||0).toFixed(2);
  pnlValueEl.textContent = pnlText || pnlValueEl.textContent;
  
  // Update PnL color based on value
  if (pnlText && pnlText.includes('+')) {
    pnlValueEl.style.color = '#00ff88';
  } else if (pnlText && pnlText.includes('-')) {
    pnlValueEl.style.color = '#ff4d4d';
  } else {
    pnlValueEl.style.color = 'var(--muted)';
  }
}

function updateAIStatus(status, state='online') {
  const indicator = aiStatusEl.querySelector('.status-indicator');
  indicator.className = 'status-indicator';
  
  if (state === 'online') indicator.classList.add('status-online');
  else if (state === 'offline') indicator.classList.add('status-offline');
  else if (state === 'paused') indicator.classList.add('status-paused');
  
  aiStatusEl.innerHTML = `${indicator.outerHTML} ${status}`;
}

/* ============================
   Core update loop: predictive + allocation
   ============================ */

function cycleTick(){
  if (!running) return;
  
  // compute predictive states
  const states = predictor.getThreeStates(portfolioValue);
  const { chosen, alternatives, nodeScore } = predictor.chooseState(states, 7, 3);
  lastChosen = chosen;

  // compute total and apply tax & healthcare VAT per address
  let total = 0;
  const balances = chosen.balances || {};
  const addresses = Object.keys(balances);
  
  for (const addr of addresses){
    let bal = Number(balances[addr] || 0);
    // tax: collect from each balance
    const postTax = taxPool.collect(bal);
    // healthcare vat: a portion of original balance goes to healthcare
    const vat = health.applyVAT(bal);
    // we treat postTax as the retained balance for portfolio (simplified)
    balances[addr] = +postTax.toFixed(6);
    total += postTax;
  }

  // update ledger balances to match chosen state's post-tax balances
  for (const [addr, bal] of Object.entries(balances)){
    if (sim.ledger.addresses.has(addr)){
      sim.ledger.addresses.set(addr, +bal);
    } else {
      sim.createAddress(addr, bal);
    }
  }

  // portfolio metrics
  const prev = portfolioValue;
  portfolioValue = total;
  const changePercent = prev ? ((portfolioValue - prev)/Math.abs(prev)) * 100 : 0;
  const changeAmount = portfolioValue - prev;
  const pnlText = `${changeAmount>=0?'+':''}$${changeAmount.toFixed(2)} (${changePercent.toFixed(2)}%)`;
  updatePortfolioUI(portfolioValue, pnlText);

  // chart update (push predictive values)
  liteChart.push(portfolioValue);

  // AI status logic: choose status based on entropy and cycle
  const statusList = ["SCANNING","ANALYZING","DETECTING","CALCULATING","OPTIMIZING","EXECUTING","MONITORING"];
  const idx = ( (chosen.entropy.index || chosen.entropy.value) + (chosen.cycle||0) ) % statusList.length;
  const status = statusList[idx];
  updateAIStatus(status, 'online');
  appendAI(`Cycle ${chosen.cycle} chosen (nodeScore=${nodeScore}). Status=${status}`, 'info');

  // If status implies trade, simulate a transfer between two random addresses
  if (status === 'EXECUTING'){
    // pick two addresses
    const addrs = Object.keys(sim.ledger.getAll());
    if (addrs.length >= 2){
      const a = addrs[Math.floor(Math.random()*addrs.length)];
      let b = a; while (b===a) b = addrs[Math.floor(Math.random()*addrs.length)];
      const amt = +(Math.random()*5).toFixed(4);
      const ok = sim.moveFunds(a,b,amt);
      if (ok){
        appendFeed(`TRADE: ${a} → ${b} : $${amt.toFixed(4)}`);
      } else {
        appendFeed(`TRADE FAIL (insufficient): ${a} → ${b} : $${amt.toFixed(4)}`);
      }
    }
  }

  // update tax and health UI
  updateTaxUI(); 
  updateHealthUI();
}

// run ticker every 1s
let tickInterval = setInterval(cycleTick, 1000);

/* ============================
   UI interactions
   ============================ */
btnDistributeTax.addEventListener('click', ()=>{
  const addrs = Object.keys(sim.ledger.getAll());
  taxPool.distribute(addrs, sim);
  appendAI(`Tax pool distributed across ${addrs.length} addresses`, 'success');
  updateTaxUI();
});

btnClearTax.addEventListener('click', ()=>{
  taxPool.clear();
  appendAI('Tax pool cleared', 'warning');
  updateTaxUI();
});

btnDistributeHealth.addEventListener('click', ()=>{
  const addrs = Object.keys(sim.ledger.getAll());
  health.distribute(sim, addrs);
  appendAI(`Healthcare distributed across ${addrs.length} addresses`, 'success');
  updateHealthUI();
});

btnClearHealth.addEventListener('click', ()=>{
  health.clear();
  appendAI('Healthcare reserves cleared', 'warning');
  updateHealthUI();
});

// manual buy/sell: simulate move between USD pool and token holders by mapping token to address sample
btnBuy.addEventListener('click', ()=>{
  const token = tokenSelect.value;
  const amt = Number(amountInput.value) || 0;
  if (amt <= 0) {
    appendAI(`Invalid amount: ${amt}`, 'error');
    return;
  }
  
  // treat 'alice' as liquidity pool: buy means move from tax pool to buyer -> for illustrative purposes, credit alice from tax pool if possible
  const poolSource = 'alice'; 
  const buyer = 'bob';
  
  // We'll try to move from poolSource to buyer by amt (simulate)
  const ok = sim.moveFunds(poolSource, buyer, amt);
  if(ok){ 
    appendFeed(`MANUAL BUY: ${buyer} bought ${amt} ${token} from ${poolSource}`);
    appendAI(`Manual BUY order executed: ${amt} ${token}`, 'success');
  } else { 
    appendFeed(`MANUAL BUY FAIL: insufficient funds in ${poolSource}`);
    appendAI(`Manual BUY order failed: insufficient funds`, 'error');
  }
});

btnSell.addEventListener('click', ()=>{
  const token = tokenSelect.value;
  const amt = Number(amountInput.value) || 0;
  if (amt <= 0) {
    appendAI(`Invalid amount: ${amt}`, 'error');
    return;
  }
  
  const seller = 'charlie'; 
  const poolDest = 'alice';
  const ok = sim.moveFunds(seller, poolDest, amt);
  if(ok){ 
    appendFeed(`MANUAL SELL: ${seller} sold ${amt} ${token} to ${poolDest}`);
    appendAI(`Manual SELL order executed: ${amt} ${token}`, 'success');
  } else { 
    appendFeed(`MANUAL SELL FAIL: insufficient funds in ${seller}`);
    appendAI(`Manual SELL order failed: insufficient funds`, 'error');
  }
});

btnExport.addEventListener('click', ()=>{
  const html = document.documentElement.outerHTML;
  const blob = new Blob([html], {type:'text/html'});
  const a = document.createElement('a'); 
  a.href = URL.createObjectURL(blob); 
  a.download = 'ai-bitboy-dex-export.html'; 
  document.body.appendChild(a); 
  a.click(); 
  a.remove();
  appendAI('Exported preview as HTML', 'success');
});

btnPlay.addEventListener('click', ()=>{
  if (!running){ 
    running = true; 
    tickInterval = setInterval(cycleTick, 1000); 
    appendAI('Resumed simulation', 'success');
    updateAIStatus("RUNNING", "online");
  }
});

btnPause.addEventListener('click', ()=>{
  if (running){ 
    running = false; 
    clearInterval(tickInterval); 
    appendAI('Paused simulation', 'warning');
    updateAIStatus("PAUSED", "paused");
  }
});

btnReset.addEventListener('click', ()=>{
  if (confirm('Are you sure you want to reset the simulator? All current data will be lost.')) {
    // Reset simulator
    sim = new BlockchainSimulator(Date.now());
    sim.createAddress('alice', 100);
    sim.createAddress('bob', 50);
    sim.createAddress('charlie', 75);
    
    predictor = new PredictiveEngine(sim);
    taxPool.clear();
    health.clear();
    
    // Reset UI
    portfolioValue = Object.values(sim.ledger.getAll()).reduce((a,b)=>a+b,0);
    updatePortfolioUI(portfolioValue, '+0.00 (0%)');
    updateTaxUI();
    updateHealthUI();
    liteChart.setAll(Array.from({length:50}, ()=>portfolioValue));
    
    // Clear logs
    aiLogEl.innerHTML = '';
    tradeFeedEl.innerHTML = '';
    
    appendAI('Simulator reset to initial state', 'success');
    updateAIStatus("READY", "online");
    
    if (!running) {
      running = true;
      tickInterval = setInterval(cycleTick, 1000);
    }
  }
});

/* ============================
   Initialize UI and values
   ============================ */
(function init(){
  updatePortfolioUI(portfolioValue, '+0.00 (0%)');
  updateTaxUI(); 
  updateHealthUI();
  
  // seed chart with initial balances
  liteChart.setAll(Array.from({length:50}, ()=>portfolioValue));
  
  appendAI('AI-BITBOY-DEX Simulator initialized', 'success');
  appendAI('Predictive engine started with 3-state analysis', 'info');
  appendFeed('Market feed started. Waiting for trading signals...');
  appendFeed('System time: ' + new Date().toLocaleString());
  
  // Add some initial activity to the feed
  setTimeout(() => {
    appendFeed('Initializing market data feeds...');
    appendFeed('Connected to simulated exchange API');
  }, 1000);
})();
</script>
</body>
</html>