#!/usr/bin/env bash
# Author: Aris Arjuna Noorsanto <exe.opcode@gmail.com>
# AI / AGI / AIM Unified Processing Tool
# Single-file standalone shellscript
# Compatible with Debian, Termux, Proot-Distro

set -eu
IFS=$'\n\t'

# -----------------------
# CONFIG
# -----------------------
HOME_ROOT="${HOME:-/data/data/com.termux/files/home}"
BACKUP_DIR="$HOME_ROOT/.ai_backups"
mkdir -p "$BACKUP_DIR"

UNIVERSAL_LAW=$(cat <<'EOF'
:bof:
redo complete layout and design an advanced symetrics to proximity accordance for dedicated info-quota alignments, which grant a better adjustment for leading besides subliminal range compliance promisings, that affair any competing content relations into a cognitive intuitition guidance comparison between space and gap implies, that are suggesting the viewer a subcoordinated experience alongside repetitive tasks and stoic context sortings, all cooperational aligned to timed subjects of importance accordingly to random capacity within builds of data statements, that prognose the grid reliability of a mockup as given optically acknowledged for a more robust but also as attractive rulership into golden-ratio item handling                                         :eof:                                                                        EOF                                                                          )                                                                                                                                                         OLLAMA_MODEL="2244-1"                                                                                                                                     # Repo config                                                                REPO_DIR="$HOME_ROOT/AI-BITBOY-DEX-202X"                                     REPO_URL="https://github.com/Loopshape/AI-BITBOY-DEX-202X.git"               AI_DRIVE_URL="https://ai.studio/apps/drive/1pd2jfyl-Ygx2t6WTNgqEEgXikm5DfH2h"                                                                             # -----------------------                                                    # LOGGING HELPERS                                                            # -----------------------                                                    log_info()    { printf '\033[34m[*] %s\033[0m\n' "$*"; }                     log_success() { printf '\033[32m[+] %s\033[0m\n' "$*"; }                     log_warn()    { printf '\033[33m[!] %s\033[0m\n' "$*"; }                     log_error()   { printf '\033[31m[-] %s\033[0m\n' "$*"; }                                                                                                  backup_file() {                                                                  local file="$1"                                                              if [ -f "$file" ]; then                                                          local ts=$(date +%Y%m%d%H%M%S)
        cp "$file" "$BACKUP_DIR/$(basename "$file").$ts.bak"
        log_info "Backup created: $file -> $BACKUP_DIR"
    fi                                                                       }                                                                                                                                                         # -----------------------                                                    # FETCHER                                                                    # -----------------------                                                    fetch_url() {                                                                    local url="$1"                                                               if command -v curl >/dev/null 2>&1; then                                         curl -sL "$url"
    elif command -v wget >/dev/null 2>&1; then
        wget -qO- "$url"
    else
        log_error "curl or wget required to fetch URLs"
    fi
}

get_prompt() {
    local input="$1"
    case "$input" in                                                                 http://*|https://*) fetch_url "$input" ;;                                    *)                                                                               if [ -f "$input" ]; then                                                         cat "$input"                                                             else
                echo "$input"
            fi                                                                           ;;                                                                   esac                                                                     }                                                                                                                                                         # -----------------------                                                    # BASHRC ADAPTATION                                                          # -----------------------                                                    adapt_bashrc() {                                                                 local bashrc="$HOME_ROOT/.bashrc"                                            backup_file "$bashrc"                                                        log_info "Rewriting .bashrc..."                                              cat > "$bashrc" <<EOF                                                    # ~/.bashrc adapted by AI tool                                               export PATH="\$HOME/bin:\$PATH"                                              alias ai="$HOME/bin/ai"                                                      # Universal Law embedded                                                     export UNIVERSAL_LAW="$UNIVERSAL_LAW"                                        EOF                                                                              log_success ".bashrc rewritten and environment set"                      }                                                                                                                                                         # -----------------------                                                    # AI MODES                                                                   # -----------------------
ai_file() {
    for f in "$@"; do
        [ -f "$f" ] || continue
        backup_file "$f"
        log_info "Processing file: $f"
        if command -v ollama >/dev/null 2>&1; then
            pkill ollama || true
            nohup ollama serve >/dev/null 2>&1 &
            sleep 2
            cat "$f" | ollama run "$OLLAMA_MODEL"                                    else                                                                             log_warn "Ollama not found, injecting Universal Law"                         echo "$UNIVERSAL_LAW" > "$f.processed"                                   fi                                                                       done                                                                     }                                                                                                                                                         ai_batch() {                                                                     local pattern="$1"                                                           for f in $pattern; do                                                            [ -f "$f" ] || continue                                                      ai_file "$f"                                                             done                                                                     }                                                                            
ai_env() {
    log_info "Scanning environment..."
    env | sort                                                                   df -h                                                                        ls -la "$HOME_ROOT"                                                          ls -la /etc                                                              }                                                                                                                                                         ai_pipeline() {                                                                  for f in "$@"; do                                                                [ -f "$f" ] || continue                                                      ai_file "$f"
    done
}

# -----------------------
# AGI MODES
# -----------------------
agi_watch() {
    local folder="$1"
    local pattern="${2:-*}"
    log_info "Watching $folder for changes matching $pattern"
    if ! command -v inotifywait >/dev/null 2>&1; then
        log_error "inotify-tools not installed"
        return
    fi
    inotifywait -m -r -e modify,create,move --format '%w%f' "$folder" | while read file; do
        case "$file" in
            $pattern) log_info "Change detected: $file"; ai_file "$file" ;;          esac
    done                                                                     }

agi_screenshot() {                                                               log_info "Screenshot disabled in Termux/Proot"
}

# -----------------------                                                    # REPO MANAGEMENT
# -----------------------                                                    repo_clone() {
    log_info "Cloning repo into $REPO_DIR..."
    [ -d "$REPO_DIR" ] && { log_warn "Repo dir exists, skipping clone"; return; }
    git clone "$REPO_URL" "$REPO_DIR"
    log_success "Repo cloned"
}                                                                            
repo_pull() {
    log_info "Pulling latest from $REPO_URL..."
    cd "$REPO_DIR" && git pull
    log_success "Repo updated"                                               }

repo_push() {                                                                    local msg="${1:-update}"
    log_info "Pushing changes with message: $msg"
    cd "$REPO_DIR"                                                               git add .
    git commit -m "$msg" || log_warn "No changes to commit"
    git push origin main                                                         log_success "Changes pushed"
}

repo_sync_drive() {
    log_info "Syncing with AI Studio Drive: $AI_DRIVE_URL"                       fetch_url "$AI_DRIVE_URL" > "$REPO_DIR/drive-sync.json" || log_warn "Drive fetch failed"                                                                  log_success "Drive sync complete"
}                                                                            
# -----------------------                                                    # INSTALLER
# -----------------------
install_tool() {
    adapt_bashrc                                                                 mkdir -p "$HOME/bin"
    cp -f "$0" "$HOME/bin/ai"                                                    chmod +x "$HOME/bin/ai"
    log_success "AI tool installed at $HOME/bin/ai"                          }

# -----------------------
# MAIN ARGUMENT PARSER
# -----------------------
if [ $# -eq 0 ]; then
    log_info "Usage: ai <mode> [args]"                                           log_info "Modes:"
    log_info "  init           -> install tool"                                  log_info "  - <files>      -> process file(s)"
    log_info "  * <pattern>    -> batch process"
    log_info "  .              -> environment scan"
    log_info "  : f1:f2:f3     -> pipeline process"                              log_info "  agi + <folder> -> watch folder"
    log_info "  agi -          -> screenshot (disabled)"                         log_info "  repo clone     -> clone repo"
    log_info "  repo pull      -> update repo"                                   log_info "  repo push msg  -> push changes"
    log_info "  repo sync      -> sync with AI Studio drive"                     log_info "  <prompt|url>   -> run input prompt"
    exit 0                                                                   fi

case "$1" in                                                                     init) shift; install_tool ;;
    -) shift; ai_file "$@" ;;                                                    \*) shift; ai_batch "$@" ;;
    .) ai_env ;;                                                                 :) shift; IFS=':' read -r -a files <<< "$1"; ai_pipeline "${files[@]}" ;;
    agi) shift                                                                       case "$1" in
            +|~) shift; agi_watch "$@" ;;                                                -) agi_screenshot ;;
            *) agi_watch "$@" ;;                                                     esac
        ;;
    repo)
        shift
        case "$1" in
            clone) repo_clone ;;
            pull) repo_pull ;;
            push) shift; repo_push "$@" ;;
            sync) repo_sync_drive ;;
            *) log_error "Usage: ai repo {clone|pull|push <msg>|sync}" ;;
        esac
        ;;
    *)
        PROMPT=$(get_prompt "$*")
        log_info "Running prompt on Ollama $OLLAMA_MODEL..."
        if command -v ollama >/dev/null 2>&1; then
            pkill ollama || true
            nohup ollama serve >/dev/null 2>&1 &
            sleep 2
            echo "$PROMPT" | ollama run "$OLLAMA_MODEL"
        else
            log_warn "Ollama not found, printing prompt only"
            echo "$PROMPT"
        fi
        ;;
esac
